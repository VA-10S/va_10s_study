# 보안과 프라이버시 개요

### 보안이란?

- 데이터와 자산을 안전하게 유지하는 것
- 대부분의 경우 전통적인 일반 보안(국가 안보)과 크게 다르지 않지만, 네트워크가 발달하면서 지켜야할 범위와 규모가 훨씬 늘어났다.
    - 병원 등 일상적인 서비스에서조차 개인 정보를 수집, 보관하는 경우 등이 훨씬 많아진 것이 그 예
- 보안은 사회적인 문제로서 ‘안전’에 대한 정의는 다른 이들의, 혹은 사회적인 정의와 균형을 맞춰야 한다.
    - 쇠사슬은 가장 약한 고리만큼만 강하다.

### 위협 모델 Threat Model

- 보안이 필요한 대상 목록을 정의하고, 각 보안 대상에 가해질 수 있는 공격을 열거함으로써 해당 공격을 방어하는 방법을 설계하기 위해 필요
- 보안이 필요한 대상의 가치를 고려해 적합한 비용의 보안 방식을 채택
    - 학교 사물함 보안에 전문 보디가드를 고용하는 것은 넌센스
- 공격자가 통과하려면 비싸지만 방어자에게는 비용이 적게 드는 방어를 사용하는 것이 이상적

### 신뢰 trust

- 보안은 신뢰를 기반으로 함
    - 컴퓨터를 사용한다면 서드파티(third-party) 소프트웨어 등 선택할 수 없는 대상에 의존하게 됨
- 따라서 신뢰 대상은 최소한으로 유지
- 신뢰 위반의 종류
    - 의도적 deliberate
    - 무능 incompetent
    - 부정직 disingenuous
        - 클렙토그래피 kleptography: 공격자가 (사용자 모르게) 비밀리에 안전하게 (암호화되지 않은) 정보를 빼내는 수단

### 공격 표면 attack surface

- 정보를 탈취하기 위해 공격하는 대상
- 인증 authorization: 사용자가 해당 정보에 접근할 수 있도록 확인하는 방식으로 사물함의 자물쇠 등
- 백도어 back-door: 관리자용으로 편의상 만들어진 루트로 마스터키 등
    - 이를 통하면 모든(혹은 넓은 범위의) 데이터에 접근할 수 있는 권한 privilege 확보 가능

### 통신 보안

- 인증 authentication: 대상이 실제 대상인지 확인하는 것
    - ↔ 권한부여 authorization: 제대로된 자격증명 credential을 제공하지 않는 사람에게는 접근 제한
    - 2단계 인증 2FA, two-factor authentication
        - 휴대전화로 OTC one-time code / OTP one-time password 전송 등
- 진본성 authenticity: 데이터가 원본 데이터임을 증명하는 것
- 중간자 공격 man-in-the-middle attack: 두 당사자 중간에 공격자가 칩임해 통신을 가로채거나 변경

위 문제들은 크립토그래피(cryptography)로 해결 가능

다만 현대에 이르러 대부분의 데이터가 디지털화되면서 아래와 같은 다양한 경우가 가능

- 서비스 거부 공격 Dos, denial of service: 서비스 마비
- 분산 서비스 거부 공격 DDos, distributed denial of service: 공격자가 대규모 협력을 통해 대상 서비스를 마비시키는 것
- 공격자가 추적을 막기 위해 프록시 proxy 사용: 타 기계에 멀웨어 삽입 후 command and control 메시지 전송
- 크립토그래피 시스템 공격: 잘 설계된 시스템을 공격하기는 다소 어려움
- 사회적 social 공격: 이메일에 악성코드 전송 등
- 취약점 공격: 웹페이지 조작 등
- 딥페이크 deepfake 기술을 통한 가짜 데이터 범람
    - 자동녹음전화에서 목소리 샘플을 채취하는 경우가 많으니 조심하세요

### 메타데이터 metadata 수집

- 메타데이터: 데이터에 관한 데이터
- 휴대전화의 위치기록 수집 등

# Cryptography (암호화 기술)

- 보안, 프라이버시, 데이터 진실성 증명에 유용
- 스테가노그래피 steganography
    - 어떤 내용을 다른 내용 속에 감추는 방식
    - 웹페이지에서 개별 사용자 식별 목적의 URL을 이미지 등으로 포함하는 경우
    - 컴퓨터 프린터 출력물에 시리얼 번호를 인코딩해서 추가하는 경우
- 치환 암호 substitution cipher
    - 암호화 encrypt ↔ 복호화 decrypt
    - 암호문 ciphertext ↔ 평문 plain text
    - [https://school.programmers.co.kr/learn/courses/30/lessons/12926?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/12926?language=javascript)
- 전치 암호 transposition cipher
    - 스키테일 scytale: 문자 위치를 뒤섞어서 인코딩하는 방법
- 일회용 패드 one-time pad
    - 중복되지 않는 유일한/일회용의 치환 암호 모음
    - 필요조건
        - 양 당사자가 똑같은 패드를 사용해야 한다.
        - 당사자는 서로 동기화 되어야(같은 페이지에 있는 암호를 사용) 한다.
        - 패턴 반복을 피하려면 패드가 메시지만큼 길어야 한다.
    - 키 길이의 제약 때문에 현실에서 사용하기 쉽지 않음

### 공개키 암호 public key cryptography

- 공개키 public key
- 비밀키 private key
- 트랩도어 함수 trapdoor 함수
    - 한 방향으로는 계산하기 쉽지만, 비밀을 알지 못하면 반대쪽 방향으로는 계산이 어려운 함수
- 트랩도어 함수를 계산할 수 있는 정보를 공개키로 사용하고, 이를 되돌릴 때 필요한 정보로 비밀키를 사용
- 각 메시지마다 세션 키를 새로 만들면 키가 노출되어도 데이터 노출 비율을 줄일 수 있다. 이를 전방향 안전성 forward secrecy라고 한다.
- RSA 알고리즘
    - 비대칭 암호화 알고리즘으로 되돌릴 수 있는 연산
    - [https://stackoverflow.com/questions/733692/sha1-vs-rsa-whats-the-difference-between-them](https://stackoverflow.com/questions/733692/sha1-vs-rsa-whats-the-difference-between-them)

### 암호학적 해시 함수

- 단방향 one-way 특성으로 되돌릴 수 없는 연산 (해시값으로 원래 값 계산 불가/어려움)
- 비슷한 데이터의 해시값은 서로 연관관계가 없어야 한다.
- SHA-1 Secure Hash Algorithm #1
- 도용이 어렵고 해시 충돌이 아주 드물어야 한다.

### 디지털 서명 digital signature

- 정합성 integrity: 메시지가 변조됐는지 검증 가능
    - 데이터의 암호 해시값을 계산해 데이터 뒤에 추가, 수신자는 해당 값 복호화 후 검증
- 부인 방지 non-repudation: 서명이 있으므로 송신자가 송신했음을 확인 가능
- 인증 authentication: 해시값으로 변조여부 확인해 수신한 메시지가 원본과 같은 메시지임을 확인

### 공개키 인프라

- 공개키 인프라스트럭쳐 PKI, public key infrastructure
- 인증기관 CA, certificate authority이 발행기관의 키임을 인증

# 소프트웨어 예방조치

- 안전이 필요한 부분을 가능한 적게
    - 로그인이 필요한 구간이 많아지면 유저는 계속 로그인 상태를 유지할 것
- 로직을 꼼꼼하게 살피고 오류 메시지에 유의
    - 라이브러리가 메모리 경계를 넘어간다면 이상한 현상이 발생할 수 있다.
- 공격 표면을 최소화
    - 복잡한 소프트웨어는 필연적으로 버그가 생길 수밖에 없음에 유의
    - 새로운 기능이 추가되면 공격표면도 증가하므로 코드는 가능한 간단하게 유지하기
- fuzzing
    - [https://ko.wikipedia.org/wiki/퍼징](https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%A7%95)
    - (종종 자동화 또는 반자동화된) 소프트웨어 테스트기법으로 컴퓨터 프로그램에 유효한, 예상치 않은 또는 무작위 데이터를 입력하여 충돌, 빌트인 코드 검증, 메모리 누수 발견 수행
- 좋은 난수를 생성하기는 힘들다.
    - 논리 회로로는 진짜 난수를 생성하기 어렵다. 의사난수 pseudo random number 에서는 같은 숫자에서 시작하면 같은 순서로 난수가 생성된다.
    - 무작위성을 보장하기 위한 엔트로피 소스의 성능이 중요하다. 마우스 움직임이나 칩에서 발생하는 열 잡음 등을 사용하기도 한다.
- 서드파티 third party 사용은 신중하게
    - 코드 개발사 vendor 의 코드에 허점이 있거나, 이후 유지보수를 해주지 않을 위험이 있다.
    - 실제 사용하는 코드와 전체 패키지 크기 사이의 비율을 구해보는 것도 유용
- 디버깅 코드는 반드시 제거
- C 계열에서 동적 메모리 사용시 malloc을 이용하자
    - 동적으로 할당한 메모리를 해제하기 전에 민감한 정보를 지워야 한다.
    - 메모리를 줄이는 경우 반환될 영역에 있는 정보를 지워야 한다.
        - 블록에 있는 데이터가 다른 영역으로 옮겨지면서 기존 블록에는 그대로 남아있을 수 있다.
- 가비지 컬렉션이나 플래시 메모리의 부하 평탄화 load leveling 기능에서는 예전 정보를 덮어쓴다는 보장이 없다
- 입력 데이터가 실행되는 일은 없도록
    - `eval`
    - SQL injection
    - 댓글을 sanitize하지 않으면 html, 그리고 js가 주입될 수 있다.

<aside>
💡 보안은 아주 어려운 분야이며 아마추어가 할 수 있는 일이 아니다. 혼자 보안을 해결하려 하지 마라.

</aside>
