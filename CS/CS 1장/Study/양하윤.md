# 양하윤

## 공부 내용

**Bit란,**

컴퓨터는 비트를 가지고 노는 기계다.

인간이 사용하는 언어의 문자와 매칭되는 것이 바로 비트(Binary 2진법 + Digit 10진법)이다.

**기호**

비트에 Digit 이란 단어가 포함된 게 조금 이상하지만, 비트는 2진법을 사용한다.

그래서 두 가지 기호 중 하나만 담아서 사용할 수 있다.

기호라는 개념은 추상적이라서 무엇이든 올 수 있다. 쌀/보리 일수도 있고 점/선 일 수도 있다. 

그래서 비트가 어떤 기호로 이루어져있는지 가정에 근거해서 살펴보는 게 가능하다.

그럼 어떻게 비트를 사용할 수 있을까?

**논리연산**

비트사용법

어떤 질문에 대한 대답을 true/false(예 또는 아니오) 로 표현할 수 있다. 만약에 예 아니오로 대답할 수 없는 건 비트로 표현할 수 없다. ex) 학교에 가니? true/false (o) 몇시에 가니? …(x)

다음과 같이 비트로 새로운 비트를 만들어내는 것을 논리연산이라고 부른다.

- 밖에 비가 내리고 있거나 춥다면 코트를 입어라 → 추운게 참이고, 비가 내리는 게 참이라면, 코트를 입어라
- 눈이 오고 학교에 가는 날이 아니라면 스키를 타라 → 눈이 오고 있는게 참이고, 학교에 가는날이 거짓이라면, 스키를 타라

**불리언 대수**

`AND` 춥고 && 비가 내리면 ⇒ 코트를 입어

`OR` 빵이 있거나 || 시리얼이 있으면 ⇒ 우유를 먹어

`NOT` !true ⇒ false

`XOR` 배타적OR : 첫번째 비트와 두번째 비트가 다른 boolean 값일 때만 참이 된다.

**드모르간의 법칙**

`!(!a || !b)` === `a && b` 

NOT을 충분히 사용하면 AND 연산을 OR 로 바꿀 수 있다.

---

논리연산자가 너무 많으면 가독성을 해치므로 드모르간의 법칙으로 간결하게 표현할 수 있다. 

*🧐컨벤션에 관한 고찰* 

**단축평가** : 논리 연산의 결과가 **왼쪽 피 연산자의 평가 결과만으로 결정**되기 때문에 오른쪽 피연산자의 평가는 수행하지 않아도 된다.

F && T = F

F && F = F

T || F = T

T || T = T

**제어문 작성시** 

```jsx
// bad
!isRunning && startRunning();

// good
if (!isRunning) startRunning();
```

제어문 `if ( ... )` 대신 논리 연산자 `||` `&&` 를 사용하지 않는다. 논리연산자는 truthy / falsy 한 값을 판별하거나 할당할 때 사용한다.

논리연산자는 왼쪽 피연산자부터 실행해 오른쪽으로 진행하며 피연산자를 평가하는 연산자이다.

&& 연산자는 오른쪽 연산자까지 모두 평가를 마쳐야 truthy 인 값을 반환하기 때문에 우측에 실행문이 놓이는 것은 논리연산자의 의도와 맞지 않다.

그리고 `&&` 를 사용한 코드가 훨씬 짧긴 하지만, if 문을 사용했을 때 개발자의 의도가 명확히 드러나고 가독성이 더 좋다.

---

**2진법**

16을 비트로 표현하면 10000 ⇒ 5비트 수

변경했을 때 변하는 정도를 기준으로 가장 오른쪽의 비트를 가장 작은 유효비트 LSB, 가장 왼쪽의 비트를 가장 큰 유효비트 MSB 라고 부른다.

**오버플로**

덧셈의 결과가 비트의 개수로 표현할 수 있는 범위를 벗어나는 것

ex. 4비트 수끼리 더했을 때 1001 + 1000 을 더하면 10001 이지만 4비트를 넘어가기 때문에 0001이 된다.

이때 컴퓨터는 조건코드 레지스터 라는 곳에 오버플로비트를 비롯한 예외에 해당하는 정보를 담아둔다.

`노                         잼                            구                         간`

**아스키코드**

ASCII 정보교환을 위한 미국 표준 코드.

키보드에 있는 모든 기호에 대해 7비트 수 값을 할당.

옛날 옛적에는 비트가 비쌌기 때문에 적은 비트로 문자를 표현했지만, 
지금은 비트가격이 떨어졌기 때문에 16비트 기반의 유니코드가 표준이 됐고 지금은 유니코드가 21비트까지 확장됐다.

+또한 아스키코드에는 영어밖에 없기 때문에 새로운 기준이 필요하기도 했다.

---

***🧐 아스키코드는 사실 8비트 수?***

컴퓨터는 우리의 문자를 알지 못하기 때문에 컴퓨터가 이해할 수 있는 숫자로 알려줘야 하는데, 디바이스별로 다른 기준을 가지고 있으면 안되기 때문에 표준이 되는 코드가 여기저기 생겨났고, 국제적인 규칙 중에 하나로 아스키코드가 만들어졌다.

추가적으로 검색해보니 책에는 7비트수라고 단정짓는 반면에, 아스키코드는 8비트수라는 문서를 발견했다.

표를 봐도 A(65)를 2진수로 변환하면 `100 0001` ! 8비트수가 아닌 7비트수가 맞다.

남은 1비트는 **parity bit 패리티 비트** 라고 부르는데, 이 비트는 데이터의 전달 과정에서 오류가 생기는 것을 검사하는 비트이다. 

보내고자 하는 특정 비트의 끝에 1또는 0의 패리티 비트를 더해서 전송할 수 있는데

`1 0 0 1 0 1 0 1` 이라는 8비트수가 있다고 가정했을 때,

짝수 패리티: 1의 총 개수가 짝수가 되게 하기 위해서 짝수패리티를 0으로 설정해서 보내고,
홀수패리티: 1의 총 개수를 홀수로 만들기 위해서 홀수패리티 1을 같이 보내는 것.

보내기 전에 짝수로 보낼 건지, 홀수로 보낼 지 약속을 하고 데이터를 전송하게 된다.

Q. 왜 이런 과정이 필요한거임?

A. 통신을 하는 과정에서 비트를 단위시간당 하나씩 보내게 되어있는데, 알 수 없는 요인에 의해서 비트의 값이 틀어져 0이 1이 되거나 1이 0이 되었을 때 이를 확인하는 일종의 보호장치이다.
짝수패리티를 설정했는데 전송중에 1이 소실된다면, 모든 비트수를 더했을때 홀수가 나올 것이니 문제를 인지할 수 있다.

일반적으로 송수신 거리가 길 때 사용된다고 한다.

[https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ansdbtls4067&logNo=220886661657](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ansdbtls4067&logNo=220886661657)

---

## 흥미로웠던 내용

아스키코드

##